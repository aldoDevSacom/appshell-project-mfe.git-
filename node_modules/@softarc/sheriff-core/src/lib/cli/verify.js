"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.verify = verify;
const has_encapsulation_violations_1 = require("../checks/has-encapsulation-violations");
const traverse_file_info_1 = require("../modules/traverse-file-info");
const check_for_dependency_rule_violation_1 = require("../checks/check-for-dependency-rule-violation");
const getFs_1 = __importDefault(require("../fs/getFs"));
const cli_1 = require("./cli");
const get_entries_from_cli_or_config_1 = require("./internal/get-entries-from-cli-or-config");
const log_info_for_missing_sheriff_config_1 = require("./internal/log-info-for-missing-sheriff-config");
function verify(args) {
    const fs = (0, getFs_1.default)();
    const projectEntries = (0, get_entries_from_cli_or_config_1.getEntriesFromCliOrConfig)(args[0]);
    (0, log_info_for_missing_sheriff_config_1.logInfoForMissingSheriffConfig)(projectEntries[0].projectInfo);
    // Keep track of overall status to determine final process exit code
    let hasAnyProjectError = false;
    // Store validation results for each project
    const projectValidations = new Map();
    for (const projectEntry of projectEntries) {
        const projectName = projectEntry.projectName;
        // Initialize validation data for this project
        const validation = {
            deepImportsCount: 0,
            dependencyRulesCount: 0,
            filesCount: 0,
            hasError: false,
            validationsMap: {},
            encapsulations: [],
            dependencyRuleViolations: [],
        };
        projectValidations.set(projectName, validation);
        for (const { fileInfo } of (0, traverse_file_info_1.traverseFileInfo)(projectEntry.projectInfo.fileInfo)) {
            const encapsulations = Object.keys((0, has_encapsulation_violations_1.hasEncapsulationViolations)(fileInfo.path, projectEntry.projectInfo));
            const dependencyRuleViolations = (0, check_for_dependency_rule_violation_1.checkForDependencyRuleViolation)(fileInfo.path, projectEntry.projectInfo);
            const projectValidation = projectValidations.get(projectName);
            projectValidation.encapsulations = encapsulations;
            projectValidation.dependencyRuleViolations = dependencyRuleViolations;
            if (encapsulations.length > 0 || dependencyRuleViolations.length > 0) {
                projectValidation.hasError = true;
                projectValidation.filesCount++;
                projectValidation.deepImportsCount += encapsulations.length;
                projectValidation.dependencyRulesCount +=
                    dependencyRuleViolations.length;
                hasAnyProjectError = true;
                const dependencyRules = dependencyRuleViolations.map((violation) => `from tag ${violation.fromTag} to tags ${violation.toTags.join(', ')}`);
                const relativePath = fs.relativeTo(fs.cwd(), fileInfo.path);
                projectValidation.validationsMap[relativePath] = {
                    encapsulations,
                    dependencyRules,
                };
            }
        }
    }
    cli_1.cli.log('');
    cli_1.cli.log(cli_1.cli.bold('Verification Report'));
    // Process each project's validation results
    for (const [projectName, validation] of projectValidations.entries()) {
        cli_1.cli.log('');
        if (projectName !== get_entries_from_cli_or_config_1.DEFAULT_PROJECT_NAME) {
            cli_1.cli.log(cli_1.cli.bold(`Project: ${projectName}`));
            cli_1.cli.log('');
        }
        if (validation.hasError) {
            cli_1.cli.log('Issues found:');
            cli_1.cli.log(`  Total Invalid Files: ${validation.filesCount}`);
            cli_1.cli.log(`  Total Encapsulation Violations: ${validation.deepImportsCount}`);
            cli_1.cli.log(`  Total Dependency Rule Violations: ${validation.dependencyRulesCount}`);
            cli_1.cli.log('----------------------------------');
            cli_1.cli.log('');
            // Display detailed validation information for this project
            for (const [file, { encapsulations, dependencyRules }] of Object.entries(validation.validationsMap)) {
                cli_1.cli.log('|-- ' + file);
                if (encapsulations.length > 0) {
                    cli_1.cli.log('|   |-- Encapsulation Violations');
                    encapsulations.forEach((encapsulation) => {
                        cli_1.cli.log('|   |   |-- ' + encapsulation);
                    });
                }
                if (dependencyRules.length > 0) {
                    cli_1.cli.log('|   |-- Dependency Rule Violations');
                    dependencyRules.forEach((dependencyRule) => {
                        cli_1.cli.log('|   |   |-- ' + dependencyRule);
                    });
                }
            }
        }
        else {
            if (projectValidations.size > 1) {
                cli_1.cli.log('');
                cli_1.cli.log('\u001b[32mNo issues found for this project. Well done!\u001b[0m');
            }
            else {
                cli_1.cli.log('\u001b[32mNo issues found. Well done!\u001b[0m');
            }
        }
    }
    // End process based on overall status
    if (hasAnyProjectError) {
        cli_1.cli.endProcessError();
    }
    else {
        if (projectValidations.size > 1) {
            cli_1.cli.log('');
            cli_1.cli.log('\u001b[32mAll projects validated successfully!\u001b[0m');
        }
        cli_1.cli.endProcessOk();
    }
}
//# sourceMappingURL=verify.js.map